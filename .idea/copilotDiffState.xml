<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/preprocessing/RfamSeed/batch_rfam_g4.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/preprocessing/RfamSeed/batch_rfam_g4.py" />
              <option name="originalContent" value="# -*- coding: utf-8 -*-&#10;import os&#10;import sys&#10;import argparse&#10;import subprocess&#10;&#10;&#10;def get_all_fam_ids(seed_path):&#10;    fam_ids = []&#10;    with open(seed_path, encoding=&quot;iso-8859-1&quot;) as f:&#10;        for line in f:&#10;            if line.startswith(&quot;#=GF AC&quot;):&#10;                fam_id = line.split()[2].strip()&#10;                fam_ids.append(fam_id)&#10;    return fam_ids&#10;&#10;&#10;def ungapped_len(seq):&#10;    return len([c for c in seq if c not in '.-~'])&#10;&#10;&#10;def filter_stk_by_length(src_stk, target_len, out_stk):&#10;    &quot;&quot;&quot;Write blocks from src_stk that contain at least one sequence with ungapped length == target_len to out_stk.&#10;    Returns True if any block was written.&#10;    &quot;&quot;&quot;&#10;    any_written = False&#10;    # read with utf-8 because the generated .stk is written utf-8&#10;    with open(src_stk, 'r', encoding='utf-8') as f:&#10;        block = []&#10;        for line in f:&#10;            block.append(line)&#10;            if line.strip() == '//':&#10;                seqs = {}&#10;                for bl in block:&#10;                    if bl.strip() == '//' or bl.startswith('#'):&#10;                        continue&#10;                    parts = bl.rstrip('\n').split()&#10;                    if len(parts) &gt;= 2:&#10;                        name = parts[0]&#10;                        seq = ''.join(parts[1:])&#10;                        seqs.setdefault(name, '')&#10;                        seqs[name] += seq&#10;                ok = any(ungapped_len(s) == target_len for s in seqs.values())&#10;                if ok:&#10;                    with open(out_stk, 'a', encoding='utf-8') as fout:&#10;                        for bl in block:&#10;                            fout.write(bl)&#10;                    any_written = True&#10;                block = []&#10;        # final block if file doesn't end with //&#10;        if block:&#10;            seqs = {}&#10;            for bl in block:&#10;                if bl.strip() == '//' or bl.startswith('#'):&#10;                    continue&#10;                parts = bl.rstrip('\n').split()&#10;                if len(parts) &gt;= 2:&#10;                    name = parts[0]&#10;                    seq = ''.join(parts[1:])&#10;                    seqs.setdefault(name, '')&#10;                    seqs[name] += seq&#10;            ok = any(ungapped_len(s) == target_len for s in seqs.values())&#10;            if ok:&#10;                with open(out_stk, 'a', encoding='utf-8') as fout:&#10;                    for bl in block:&#10;                        fout.write(bl)&#10;                any_written = True&#10;    return any_written&#10;&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser()&#10;    parser.add_argument(&quot;--seed&quot;, required=True, help=&quot;Rfam.seed file path&quot;)&#10;    parser.add_argument(&#10;        &quot;--output_stk&quot;,&#10;        required=True,&#10;        help=&quot;Root output folder (will save .stk under &lt;output_stk&gt;/rfam_stk)&quot;,&#10;    )&#10;    parser.add_argument(&#10;        &quot;--output_g4&quot;,&#10;        required=True,&#10;        help=&quot;Root output folder for G4 files (defaults: unaligned in &lt;output_g4&gt;/rfam_unaligned, aligned in &lt;output_g4&gt;/rfam_aligned)&quot;,&#10;    )&#10;    parser.add_argument(&#10;        &quot;--output_unaligned&quot;,&#10;        required=False,&#10;        help=&quot;Optional: output folder for unaligned .txt files (overrides default &lt;output_g4&gt;/rfam_unaligned)&quot;,&#10;        default=None,&#10;    )&#10;    parser.add_argument(&#10;        &quot;--output_aligned&quot;,&#10;        required=False,&#10;        help=&quot;Optional: output folder for aligned .txt files (overrides default &lt;output_g4&gt;/rfam_aligned)&quot;,&#10;        default=None,&#10;    )&#10;    # New options&#10;    parser.add_argument(&quot;-n&quot;, type=int, default=0, help=&quot;Process only first N families (0 = all)&quot;)&#10;    parser.add_argument(&quot;--target&quot;, type=int, default=0, help=&quot;Target ungapped sequence length to filter for (0 = no filtering)&quot;)&#10;    parser.add_argument(&quot;--only-filter&quot;, action='store_true', help=&quot;Only write filtered .stk, do not run G4 processing&quot;)&#10;&#10;    args = parser.parse_args()&#10;&#10;    # prepare directories&#10;    stk_dir = os.path.join(args.output_stk, &quot;rfam_stk&quot;)&#10;    os.makedirs(stk_dir, exist_ok=True)&#10;&#10;    una_dir = args.output_unaligned or os.path.join(args.output_g4, &quot;rfam_unaligned&quot;)&#10;    ali_dir = args.output_aligned or os.path.join(args.output_g4, &quot;rfam_aligned&quot;)&#10;    os.makedirs(una_dir, exist_ok=True)&#10;    os.makedirs(ali_dir, exist_ok=True)&#10;&#10;    script_dir = (&#10;        os.path.abspath(os.path.dirname(__file__))&#10;        if &quot;__file__&quot; in globals()&#10;        else os.getcwd()&#10;    )&#10;&#10;    fam_ids = get_all_fam_ids(args.seed)&#10;    print(f&quot;Found {len(fam_ids)} families in {args.seed}.&quot;)&#10;&#10;    processed = 0&#10;    for fam_id in fam_ids:&#10;        if args.n and processed &gt;= args.n:&#10;            break&#10;&#10;        stk_path = os.path.join(stk_dir, f&quot;{fam_id}.stk&quot;)&#10;        una_path = os.path.join(una_dir, f&quot;{fam_id}_unaligned.txt&quot;)&#10;        ali_path = os.path.join(ali_dir, f&quot;{fam_id}_aligned.txt&quot;)&#10;&#10;        # Step 1: generate .stk file using _makeRfamSeedSto.py&#10;        cmd_sto = [sys.executable, &quot;_makeRfamSeedSto.py&quot;, fam_id, args.seed, &quot;--out_stk&quot;, stk_path]&#10;        print(f&quot;Generating {stk_path} ...&quot;)&#10;        subprocess.run(cmd_sto, cwd=script_dir, check=True)&#10;&#10;        # If target filtering requested, filter generated stk and operate on filtered file&#10;        if args.target and args.target &gt; 0:&#10;            stk_target = os.path.join(stk_dir, f&quot;{fam_id}_{args.target}.stk&quot;)&#10;            # remove existing filtered file to avoid appending to old content&#10;            if os.path.exists(stk_target):&#10;                os.remove(stk_target)&#10;            try:&#10;                any_written = filter_stk_by_length(stk_path, args.target, stk_target)&#10;            except Exception as e:&#10;                print(f&quot;Error while filtering {stk_path}: {e}&quot;, file=sys.stderr)&#10;                any_written = False&#10;&#10;            if any_written:&#10;                print(f&quot;Wrote filtered {stk_target}&quot;)&#10;                if not args.only_filter:&#10;                    out_una = os.path.join(una_dir, f&quot;{fam_id}_{args.target}_unaligned.txt&quot;)&#10;                    out_ali = os.path.join(ali_dir, f&quot;{fam_id}_{args.target}_aligned.txt&quot;)&#10;                    cmd_g4 = [sys.executable, &quot;_make_input_consG4.py&quot;, stk_target, out_una, out_ali]&#10;                    print(f&quot;Generating G4 files for {fam_id} (target {args.target}) ...&quot;)&#10;                    subprocess.run(cmd_g4, cwd=script_dir, check=True)&#10;                    print(f&quot;Generated {out_una} and {out_ali}&quot;)&#10;            else:&#10;                print(f&quot;No blocks with target length {args.target} in {stk_path}; skipping G4 processing.&quot;)&#10;        else:&#10;            # no filtering requested: run original behaviour&#10;            print(f&quot;Generating G4 files for {fam_id} ...&quot;)&#10;            subprocess.run([sys.executable, &quot;_make_input_consG4.py&quot;, stk_path, una_path, ali_path], cwd=script_dir, check=True)&#10;&#10;        processed += 1&#10;&#10;    print(&quot;All selected families processed.&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="# -*- coding: utf-8 -*-&#10;import os&#10;import sys&#10;import argparse&#10;import subprocess&#10;&#10;&#10;def get_all_fam_ids(seed_path):&#10;    fam_ids = []&#10;    with open(seed_path, encoding=&quot;iso-8859-1&quot;) as f:&#10;        for line in f:&#10;            if line.startswith(&quot;#=GF AC&quot;):&#10;                fam_id = line.split()[2].strip()&#10;                fam_ids.append(fam_id)&#10;    return fam_ids&#10;&#10;&#10;def ungapped_len(seq):&#10;    return len([c for c in seq if c not in '.-~'])&#10;&#10;&#10;def filter_stk_by_length(src_stk, target_len, out_stk):&#10;    &quot;&quot;&quot;Write blocks from src_stk that contain at least one sequence with ungapped length == target_len to out_stk.&#10;    Returns True if any block was written.&#10;    &quot;&quot;&quot;&#10;    any_written = False&#10;    # read with utf-8 because the generated .stk is written utf-8&#10;    with open(src_stk, 'r', encoding='utf-8') as f:&#10;        block = []&#10;        for line in f:&#10;            block.append(line)&#10;            if line.strip() == '//':&#10;                seqs = {}&#10;                for bl in block:&#10;                    if bl.strip() == '//' or bl.startswith('#'):&#10;                        continue&#10;                    parts = bl.rstrip('\n').split()&#10;                    if len(parts) &gt;= 2:&#10;                        name = parts[0]&#10;                        seq = ''.join(parts[1:])&#10;                        seqs.setdefault(name, '')&#10;                        seqs[name] += seq&#10;                ok = any(ungapped_len(s) == target_len for s in seqs.values())&#10;                if ok:&#10;                    with open(out_stk, 'a', encoding='utf-8') as fout:&#10;                        for bl in block:&#10;                            fout.write(bl)&#10;                    any_written = True&#10;                block = []&#10;        # final block if file doesn't end with //&#10;        if block:&#10;            seqs = {}&#10;            for bl in block:&#10;                if bl.strip() == '//' or bl.startswith('#'):&#10;                    continue&#10;                parts = bl.rstrip('\n').split()&#10;                if len(parts) &gt;= 2:&#10;                    name = parts[0]&#10;                    seq = ''.join(parts[1:])&#10;                    seqs.setdefault(name, '')&#10;                    seqs[name] += seq&#10;            ok = any(ungapped_len(s) == target_len for s in seqs.values())&#10;            if ok:&#10;                with open(out_stk, 'a', encoding='utf-8') as fout:&#10;                    for bl in block:&#10;                        fout.write(bl)&#10;                any_written = True&#10;    return any_written&#10;&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser()&#10;    parser.add_argument(&quot;--seed&quot;, required=True, help=&quot;Rfam.seed file path&quot;)&#10;    parser.add_argument(&#10;        &quot;--output_stk&quot;,&#10;        required=True,&#10;        help=&quot;Root output folder (will save .stk under &lt;output_stk&gt;/rfam_stk)&quot;,&#10;    )&#10;    parser.add_argument(&#10;        &quot;--output_g4&quot;,&#10;        required=True,&#10;        help=&quot;Root output folder for G4 files (defaults: unaligned in &lt;output_g4&gt;/rfam_unaligned, aligned in &lt;output_g4&gt;/rfam_aligned)&quot;,&#10;    )&#10;    parser.add_argument(&#10;        &quot;--output_unaligned&quot;,&#10;        required=False,&#10;        help=&quot;Optional: output folder for unaligned .txt files (overrides default &lt;output_g4&gt;/rfam_unaligned)&quot;,&#10;        default=None,&#10;    )&#10;    parser.add_argument(&#10;        &quot;--output_aligned&quot;,&#10;        required=False,&#10;        help=&quot;Optional: output folder for aligned .txt files (overrides default &lt;output_g4&gt;/rfam_aligned)&quot;,&#10;        default=None,&#10;    )&#10;    # New options&#10;    parser.add_argument(&quot;-n&quot;, type=int, default=0, help=&quot;Process only first N families (0 = all)&quot;)&#10;    parser.add_argument(&quot;--target&quot;, type=int, default=0, help=&quot;Target ungapped sequence length to filter for (0 = no filtering)&quot;)&#10;    parser.add_argument(&quot;--only-filter&quot;, action='store_true', help=&quot;Only write filtered .stk, do not run G4 processing&quot;)&#10;&#10;    args = parser.parse_args()&#10;&#10;    # prepare directories&#10;    stk_dir = os.path.join(args.output_stk, &quot;rfam_stk&quot;)&#10;    os.makedirs(stk_dir, exist_ok=True)&#10;&#10;    una_dir = args.output_unaligned or os.path.join(args.output_g4, &quot;rfam_unaligned&quot;)&#10;    ali_dir = args.output_aligned or os.path.join(args.output_g4, &quot;rfam_aligned&quot;)&#10;    os.makedirs(una_dir, exist_ok=True)&#10;    os.makedirs(ali_dir, exist_ok=True)&#10;&#10;    script_dir = (&#10;        os.path.abspath(os.path.dirname(__file__))&#10;        if &quot;__file__&quot; in globals()&#10;        else os.getcwd()&#10;    )&#10;&#10;    fam_ids = get_all_fam_ids(args.seed)&#10;    print(f&quot;Found {len(fam_ids)} families in {args.seed}.&quot;)&#10;&#10;    processed = 0&#10;    for fam_id in fam_ids:&#10;        if args.n and processed &gt;= args.n:&#10;            break&#10;&#10;        stk_path = os.path.join(stk_dir, f&quot;{fam_id}.stk&quot;)&#10;        una_path = os.path.join(una_dir, f&quot;{fam_id}_unaligned.txt&quot;)&#10;        ali_path = os.path.join(ali_dir, f&quot;{fam_id}_aligned.txt&quot;)&#10;&#10;        # Step 1: generate .stk file using _makeRfamSeedSto.py&#10;        # Ensure we pass absolute paths to subprocess so the helper script can locate files&#10;        seed_arg = os.path.abspath(args.seed) if not os.path.isabs(args.seed) else args.seed&#10;        stk_path_abs = os.path.abspath(stk_path)&#10;        cmd_sto = [sys.executable, &quot;_makeRfamSeedSto.py&quot;, fam_id, seed_arg, &quot;--out_stk&quot;, stk_path_abs]&#10;        print(f&quot;Generating {stk_path} ...&quot;)&#10;        subprocess.run(cmd_sto, cwd=script_dir, check=True)&#10;&#10;        # If target filtering requested, filter generated stk and operate on filtered file&#10;        if args.target and args.target &gt; 0:&#10;            stk_target = os.path.join(stk_dir, f&quot;{fam_id}_{args.target}.stk&quot;)&#10;            # remove existing filtered file to avoid appending to old content&#10;            if os.path.exists(stk_target):&#10;                os.remove(stk_target)&#10;            try:&#10;                any_written = filter_stk_by_length(stk_path, args.target, stk_target)&#10;            except Exception as e:&#10;                print(f&quot;Error while filtering {stk_path}: {e}&quot;, file=sys.stderr)&#10;                any_written = False&#10;&#10;            if any_written:&#10;                print(f&quot;Wrote filtered {stk_target}&quot;)&#10;                if not args.only_filter:&#10;                    out_una = os.path.join(una_dir, f&quot;{fam_id}_{args.target}_unaligned.txt&quot;)&#10;                    out_ali = os.path.join(ali_dir, f&quot;{fam_id}_{args.target}_aligned.txt&quot;)&#10;                    # use absolute paths for helper call&#10;                    stk_target_abs = os.path.abspath(stk_target)&#10;                    out_una_abs = os.path.abspath(out_una)&#10;                    out_ali_abs = os.path.abspath(out_ali)&#10;                    cmd_g4 = [sys.executable, &quot;_make_input_consG4.py&quot;, stk_target_abs, out_una_abs, out_ali_abs]&#10;                    print(f&quot;Generating G4 files for {fam_id} (target {args.target}) ...&quot;)&#10;                    subprocess.run(cmd_g4, cwd=script_dir, check=True)&#10;                    print(f&quot;Generated {out_una} and {out_ali}&quot;)&#10;            else:&#10;                print(f&quot;No blocks with target length {args.target} in {stk_path}; skipping G4 processing.&quot;)&#10;        else:&#10;            # no filtering requested: run original behaviour&#10;            print(f&quot;Generating G4 files for {fam_id} ...&quot;)&#10;            # pass absolute paths to helper script&#10;            subprocess.run([sys.executable, &quot;_make_input_consG4.py&quot;, stk_path_abs, os.path.abspath(una_path), os.path.abspath(ali_path)], cwd=script_dir, check=True)&#10;&#10;        processed += 1&#10;&#10;    print(&quot;All selected families processed.&quot;)&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>